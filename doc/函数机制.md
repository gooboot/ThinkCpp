![未命名绘图.drawio](https://think-note.oss-cn-beijing.aliyuncs.com/img/未命名绘图.drawio.png)

### 一、高级语言中的函数

高级语言中的函数是一种“有去有回”的封装体，它包括参数、局部变量、返回结果等。

**栈**，是函数调用的基础。

### 二、函数调用机制

#### 1.要传递的形参保存在什么地方？

每当要发生函数调用的时，形参都通过push指令压入栈内，C语言中默认从右往左依次入栈，如上图形参在栈中的位置对应到代码中是这样的，

```c
void foo(参数二，参数一){
    局部变量一;
    局部变量二;
}
```

每当进入到函数体内时，首先要执行的指令是

```assembly
;把ebp压栈，并把当前esp的值赋给ebp，ebp就是栈底
push ebp
mov ebp,esp
sub esp,0x40	;为局部变量分配栈空间0x40字节
```



#### 2.被调函数通过什么方式获取参数？

从上面的栈示意图可以看出形参位置，那要怎样才能获取到形参的值呢？很简单，以ebp为基址，通过偏移即可获得，如

```assembly
mov eax,[ebp + 8]	;读取参数二到eax中
mov ebx,[ebp + 12]	;读取参数一到ebx中
```

#### 3.函数体内的局部变量如何保存？

在学习高级语言时总会有这样一句话：*局部变量保存在栈中*。有没有想过，局部变量是怎么保存在栈中的？

```assembly
mov dword [ebp - 4],9	;局部变量一保存到栈中
mov dword [ebp -8],3	;局部变量二保存到栈中
```

#### 4.被调函数执行完毕后，怎么知道返回到什么地方继续执行？

**返回地址**指明了在函数执行完毕要回到的地址，它同样也是保存在栈中，它是在执行call指令语句时先把**下一条**语句的地址压入栈中

```assembly
call foo 	;先把下一条指令的地址压入栈中，然后跳往被调函数执行
....
ret			;ret指令把返回地址弹出到CS:EIP寄存器中
```

### 三、总结

- 形参和局部变量都保存在栈中
- 形参的获取：ebp + 8、ebp + 12、ebp + 16 ……
- 局部变量的保存：ebp - 4、ebp - 8、ebp - 12 ……
- 栈平衡：在c语言中栈的平衡是由调用方负责的，add esp,8。同时，被函数中你push了几次，最后就要pop几次
- 栈桢：ebp和esp之间就形成一个函数调用栈桢

